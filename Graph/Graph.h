//***********   Graph.h   ************//
//图的基类
#ifndef GRAPH_H
#define GRAPH_H

#define UNVISITED 0
#define VISITED 1


#define INFINITE 0x0fffffff // 表示无穷大
// 求最短路径时，需计算和比较INFINITE+INFINITE、INFINITE+weight，
// 因此不能定义为类型的最大值。4字节int最大值为0x7ffffffff

//Edge类
class Edge
{
public:
    int weight;    //weight是边的权
    int from;      //from是边的始点
    int to;        //to是边的终点
    Edge()   	   // 构造函数
    {
        from = -1;
        to = -1;
        weight = 0;
    }
    Edge(int f,int t,int w)     // 构造函数
    {
        from=f;
        to=t;
        weight=w;
    }
    bool operator < (const Edge &arg)
    {
        return (this->weight < arg.weight);
    };
    bool operator == (const Edge &arg)
    {
        return (this->weight == arg.weight);
    };
    bool operator > (const Edge &arg)
    {
        return (this->weight > arg.weight);
    };
    bool operator <= (const Edge &arg)
    {
        return (this->weight <= arg.weight);
    };
    bool operator >= (const Edge &arg)
    {
        return (this->weight >= arg.weight);
    };
};

// 图基类。
// 抽象类，不能实例化。其中仅包含各种实现中公用属性，
// 没有具体的结点关系实现
class Graph
{
public:
    int numVertex;             //图的顶点的个数
    int numEdge;				//图的边的数目
    int *Mark;					/*Mark指针指向保存有图的顶点的标志位的数组,标志位用来标记某顶点是否被访问过*/
    int *Indegree;				//Indegree指针指向保存有图的顶点的入度的数组
    Graph(int numVert)   		//构造函数
    {
        numVertex = numVert;      //确定图的顶点的个数
        numEdge = 0;				//确定图的边的数目
        Indegree = new int[numVertex]; /*为保存图的顶点的入度申请数组,Indegree为数组指针*/
        Mark = new int[numVertex];	 /*为图的顶点的标志位申请数组,Mark为数组指针*/

        for (int i = 0; i < numVertex; i ++)   	/*确定图的顶点的标志位和入度,即所有顶点的标志位初始化为未被访问过,入度初始化为0*/
        {
            Mark[i] = UNVISITED;
            Indegree[i] = 0;
        }
    }

    ~Graph()  				//析构函数
    {
        delete [] Mark;
        delete [] Indegree;
    }

    virtual Edge FirstEdge(int oneVertex)  	// 返回与顶点oneVertex相关联的第一条边
    {
        Edge myEdge;
        myEdge.from = oneVertex;
        myEdge.to = -1;   ///事实上不是一条实际的边，抽象类基类，不实例化！
        return myEdge;
    }

    virtual Edge NextEdge(Edge preEdge)    // 返回与边PreEdge有相同关联顶点的下一条边
    {
        return preEdge;
    }

    int VerticesNum()  		//返回图的顶点个数
    {
        return numVertex;
    }

    int EdgesNum()  			//返回图的边数
    {
        return numEdge;
    }

    int FromVertex(Edge oneEdge)    // 返回oneEdge的始点
    {
        return oneEdge.from;
    }

    int ToVertex(Edge oneEdge)  	// 返回oneEdge的终点
    {
        return oneEdge.to;
    }

    int Weight(Edge oneEdge)  		// 返回oneEdge的权值
    {
        return oneEdge.weight;
    }

    bool IsEdge(Edge oneEdge)   //如果oneEdge是边则返回TRUE，否则返回FALSE
    {
        if (oneEdge.weight > 0 && oneEdge.weight < INFINITE && oneEdge.to >= 0)
            return true;
        else
            return false;
    }

    bool IsEdgeForShortestPath(Edge oneEdge)   	//如果oneEdge是边则返回TRUE，否则返回FALSE
    {
        // 专门为最短路径算法设计，将"无穷大权边"视为边。
        // 将权为"无穷大"也看成是边，否则Dijkstra和Floyd算法中，
        // 当循环处理一个顶点的所有邻接点时，存储顺序中间出现非
        // 邻接点时，循环中止，导致后面的邻接点不被处理
        if (oneEdge.weight > 0 && oneEdge.weight <= INFINITE && oneEdge.to >= 0)
            return true;
        else
            return false;
    }

    virtual void setEdge(int from, int to, int weight) = 0;
    virtual void delEdge(int from, int to) = 0;
};

#endif // GRAPH_H
